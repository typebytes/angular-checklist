{
  "categories": {
    "architecture": {
      "title": "Architecture",
      "summary": "This category summarizes best practices regarding architecture.",
      "slug": "architecture",
      "items": [
        "Z1uCcrx",
        "l2hnF",
        "Z1xqb2O",
        "opRwV",
        "Z24l73x"
      ]
    },
    "components": {
      "title": "Components",
      "summary": "This category summarizes best practices regarding Components.",
      "slug": "components",
      "items": [
        "2eREkv",
        "1xd2Y4",
        "590AM",
        "ZXTLWo"
      ]
    },
    "ngrx": {
      "title": "NgRx",
      "summary": "This category summarizes best practices regarding NgRx.",
      "slug": "ngrx",
      "items": [
        "4gz6q",
        "2sJuJG"
      ]
    },
    "performance": {
      "title": "Performance",
      "summary": "This category contains a list of practices which will help us boost the performance of our Angular applications. It covers different topics - from server-side pre-rendering and bundling of our applications, to runtime performance and optimization of the change detection performed by the framework.",
      "slug": "performance",
      "items": [
        "2g7vDW",
        "Z8rHxb",
        "Z13mvQ4",
        "iOnTI",
        "gLB8Y",
        "Z2pAnXm",
        "AvD9O",
        "ZfxFUd"
      ]
    },
    "router": {
      "title": "Router",
      "summary": "This category summarizes best practices regarding routing.",
      "slug": "router",
      "items": [
        "PaBkH",
        "5ScV4",
        "iOnTI",
        "Z1WXxTy",
        "wpc6W"
      ]
    },
    "rxjs": {
      "title": "RxJS",
      "summary": "This category summarizes best practices regarding RxJS.",
      "slug": "rxjs",
      "items": [
        "Z1PcMvX",
        "bkHEY",
        "ZzpwmT",
        "ZHuJoA",
        "ZBbo7y"
      ]
    },
    "tooling": {
      "title": "Tooling",
      "summary": "This category summarizes best practices regarding tooling.",
      "slug": "tooling",
      "items": []
    },
    "typescript": {
      "title": "Typescript",
      "summary": "This category summarizes best practices regarding Typescript.",
      "slug": "typescript",
      "items": [
        "Z2hzSxp",
        "23KPo0",
        "12Aq23",
        "ZEhkug"
      ]
    }
  },
  "items": {
    "Z1uCcrx": {
      "id": "Z1uCcrx",
      "slug": "business-logic-in-services",
      "title": "Business Logic in Services",
      "content": "<h3>Business Logic in Services</h3>\n<p>All business logic in the application is moved into services. <a href=\"/checklist/architecture/Z24l73x\">Smart components</a> should only contain logic that is related to this specific component. For example business logic that is used to access backend resources should be abstracted into services.</p>\n"
    },
    "l2hnF": {
      "id": "l2hnF",
      "slug": "file-naming",
      "title": "File Naming",
      "content": "<h3>Separate file names with dots and dashes</h3>\n<p>It is recommended to separate words with dashes and dots to separate the descriptive name from the type. The descriptive name of a file should describe the component’s feature.</p>\n<p>Also, try to use conventional suffix that describe the type of the file, e.g. <code>.component.ts</code>, <code>.directive.ts</code>, <code>.service.ts</code>, <code>.module.ts</code>, <code>.pipe.ts</code>.</p>\n<p>Here are a few examples:</p>\n<ul>\n<li><code>app.component.ts</code></li>\n<li><code>contacts.service.ts</code></li>\n<li><code>product-list.component.ts</code></li>\n</ul>\n<p>Using such naming convention helps to provide a consistent way to find content very quickly and easily. Consistency will save you time and make you and your team more efficient.</p>\n<h3>Use the name and type of the file for your class names</h3>\n<p>If the file you are working on is <code>app.component.ts</code> it is obvious that this must be a component. It also tells us the name of this component, which is <code>app</code>. This means we’d call our class <code>AppComponent</code>:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({ ... })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> AppComponent { }\n</code></pre>\n<p>Here’s another example of a class defined in <code>product-list.component.ts</code>:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({ ... })\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> ProductListComponent { }\n</code></pre>\n"
    },
    "Z1xqb2O": {
      "id": "Z1xqb2O",
      "slug": "folder-structure",
      "title": "Folder Structure",
      "content": "<h3>Folder Structure</h3>\n"
    },
    "opRwV": {
      "id": "opRwV",
      "slug": "modules-and-services",
      "title": "Modules and Services",
      "content": "<h3>Providing services only at the root level</h3>\n<p>In Angular we have the possibility to take advantage of the injector tree to provide different service instances on different levels, e.g. component, directive or module. Whilst this can be exactly what you want, in most cases it is not the expected behavior.</p>\n<p>When you are creating a <code>SharedModule</code>, you want to use the components everywhere but only provide the services in your root module, e.g. <code>AppModule</code>. You can accomplish this by leveraging the <code>forRoot</code> convention. Your <code>SharedModule</code> would then like this:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@NgModule</span>({\n  imports: [...modules],\n  declarations: [...declarations],\n  exports: [...declarations]\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SharedModule {\n  <span class=\"hljs-keyword\">static</span> forRoot(): ModuleWithProviders {\n    <span class=\"hljs-keyword\">return</span> {\n      ngModule: SharedModule,\n      providers: [...services]\n    };\n  }\n}\n</code></pre>\n<p>Note that the actual module definion <strong>does not</strong> contain any providers.</p>\n<p>In your <code>AppModule</code>, you could use this module as follows:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@NgModule</span>({\n  imports: [\n    ...modules,\n    SharedModule.forRoot()\n  ],\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> AppModule {}\n</code></pre>\n<p>By calling the static <code>forRoot</code> method on the <code>SharedModule</code> you will import the entire module <strong>including</strong> its providers.</p>\n<p>In a feature module you would simply import the <code>SharedModule</code> <strong>without</strong> calling <code>forRoot</code>:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@NgModule</span>({\n  imports: [\n    ...modules,\n    SharedModule\n  ],\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeFeature {}\n</code></pre>\n<p>The fact that each component has its own Injector that is inherited from its parent Injector, allows us to ask for services provided at a root level. Hence, we have access to all the components, pipes, etc. provided by the <code>SharedModule</code> without creating multiple instances of its services.</p>\n<h3>Additional Resources</h3>\n<ul>\n<li><a href=\"https://blog.thoughtram.io/angular/2015/05/18/dependency-injection-in-angular-2.html\">Dependency Injection in Angular</a> by Pascal Precht</li>\n<li><a href=\"https://blog.thoughtram.io/angular/2016/09/14/bypassing-providers-in-angular-2.html\">Bypassing Providers in Angular</a> by Pascal Precht</li>\n<li><a href=\"https://blog.angularindepth.com/avoiding-common-confusions-with-modules-in-angular-ada070e6891f\">Avoiding common confusions with modules in Angular</a> by Maxim Koretskyi</li>\n</ul>\n"
    },
    "Z24l73x": {
      "id": "Z24l73x",
      "slug": "smart-and-dumb-components",
      "title": "Smart and Dumb Components",
      "content": "<h3>Smart and Dumb Components</h3>\n<p>Every major frontend framework nowadays is moving towards a component-based architecture. Components are a combination of a little bit of HTML, JavaScript and CSS. This way of working can provide us with a lot of benefits if used in the correct way.</p>\n<p>The most advocated way to use them is through smart and dumb components (there is a variety of other names as well but the general principle is the same).</p>\n<h3>Component Types</h3>\n<p><strong>Dumb Component</strong>:</p>\n<ul>\n<li>Receives data through <code>@Input</code>s and communicates only with it’s direct parent through <code>@Output</code>s.</li>\n<li>Dumb components should not receive <code>Observables</code> as inputs</li>\n<li>It does not know about the rest of the application. It is dumb and does not know where it is being used.</li>\n<li>Can contain business logic, but only logic that belongs to the scope of this component. For example, a pagination component can contain logic to calculate the number of ‘boxes’ to show. It does not know what happens when a user clicks a page number. In that case, it throws a custom event to notify its parent the that something has happened. The parent component then decides what happens.</li>\n<li>It can use other dumb components as children.</li>\n<li>It can inject services that are related to the view layer of your application (think <code>TranslateService</code>, <code>Router</code>, …) but never services to fetch its own data.</li>\n</ul>\n<p><strong>Smart Component</strong>:</p>\n<ul>\n<li>Knows about the application and will fetch data.</li>\n<li>It passes data down to dumb components as much as possible and mostly only contains the business logic to fetch the data.</li>\n<li>It is build up out of several dumb components.</li>\n<li>It listen for events thrown by the dumb components and performs the required action for them.</li>\n</ul>\n<h3>Benefits</h3>\n<ul>\n<li>Dumb components are completely reusable since they have a defined API and are independet of any buiness logic.</li>\n<li>Dumb components are easy to test as they are completely isolated.</li>\n<li>The entire architecture of your components becomes easier to reason about. If there is a business logic or data fetching problem, you know that you need to start searching in your smart components since this is the responsability of that component.</li>\n</ul>\n<h3>External Resources</h3>\n<ul>\n<li><a href=\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\">Presentational and container components</a> by Dan Abramov.</li>\n<li><a href=\"https://blog.angular-university.io/angular-2-smart-components-vs-presentation-components-whats-the-difference-when-to-use-each-and-why/\">Smart components vs Presentational components</a> by Angular University.</li>\n<li><a href=\"https://blog.strongbrew.io/the-smart-vs-dumb-components-quiz/\">The smart vs dumb component quiz</a> by Kwinten Pisman.</li>\n</ul>\n"
    },
    "2eREkv": {
      "id": "2eREkv",
      "slug": "clean-up-resource-in-ng-on-destroy",
      "title": "clean up resources in ngOnDestroy",
      "content": "<h3>Clean up the resource in <code>ngOnDestroy</code></h3>\n<p>The <code>onDestroy</code> lifecycle hook gets called whenever the component gets destroyed. This makes it the ideal place to clean up resources.</p>\n<p>For example:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent <span class=\"hljs-keyword\">implements</span> OnInit, OnDestroy {\n  timeoutId;\n  \n  ngOnInit() {\n    <span class=\"hljs-keyword\">this</span>.intervalId = setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {...}, <span class=\"hljs-number\">5000</span>); \n  }\n  \n  ngOnDestroy() {\n    clearInterval(<span class=\"hljs-keyword\">this</span>.intervalId);\n  }\n}\n</code></pre>\n"
    },
    "1xd2Y4": {
      "id": "1xd2Y4",
      "slug": "dont-use-property-bindings-for-attributes",
      "title": "don't use property bindings for attributes",
      "content": "<h3>Don’t use property bindings for attributes</h3>\n<p>When you are passing a static string to a component or an HTML tag, don’t use a property binding. Every property binding is constantly checked during change detection.</p>\n<p>For example, this:</p>\n<pre class=\"hljs\"><code>&lt;input [id]=<span class=\"hljs-string\">\"'exampleId'\"</span> /&gt;\n</code></pre>\n<p>Should be:</p>\n<pre class=\"hljs\"><code>&lt;input id=<span class=\"hljs-string\">\"exampleId\"</span> /&gt;\n</code></pre>\n"
    },
    "590AM": {
      "id": "590AM",
      "slug": "minimum-logic-in-templates",
      "title": "Minimum logic in templates",
      "content": "<h3>Minimise the logic in templates</h3>\n<p>Avoid putting to much logic in your templates. Code in your template cannot be easily tested with unit tests. Keep them as slim as possible.</p>\n<p>Instead of:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  template: <span class=\"hljs-string\">`&lt;div *ngIf=\"users &amp;&amp; users.length &gt; 1 &amp;&amp; visible\"&gt;content to show&lt;/div&gt;`</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent {\n  users: User[];\n  visible: <span class=\"hljs-built_in\">boolean</span>;\n}\n</code></pre>\n<p>Try and write:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  template: <span class=\"hljs-string\">`&lt;div *ngIf=\"usersExistsAndVisible()\"&gt;content to show&lt;/div&gt;`</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent {\n  users: User[];\n  visible: <span class=\"hljs-built_in\">boolean</span>;\n  \n  usersExistsAndVisible() {\n    <span class=\"hljs-keyword\">return</span> users &amp;&amp; users.length &gt; <span class=\"hljs-number\">1</span> &amp;&amp; visible;\n  }\n}\n</code></pre>\n<p>The <code>usersExistsAndVisible</code> is extremely easy to unit test.</p>\n"
    },
    "ZXTLWo": {
      "id": "ZXTLWo",
      "slug": "ng-oninit-vs-constructor",
      "title": "put init logic in the ngOnInit lifecycle hook",
      "content": "<h3>Put init logic int he ngOnInit lifecycle hook</h3>\n<p>The <code>constructor</code> is a default method of the class that is executed when the class is instantiated. Here, the dependencies are injected.\nThe <code>ngOnInit</code> hook will be called whenever Angular is ready prepping the component. This makes it the ideal place to put initialisation logic for your component.</p>\n"
    },
    "4gz6q": {
      "id": "4gz6q",
      "slug": "big-lists-are-normalised",
      "title": "Big lists are normalised",
      "content": "<h3>Big lists are normalised</h3>\n<p>The easiest way to store data into the store is through arrays. When you perform a backend call, you probably get an array back as a result anyway and you can just add this to the store.\nThe big downside to this approach is that, if you want to for example remove an element from the array, you first have to find the element before you can remove it. This means that the big O notation of finding an element like that is O(n). While for smaller lists, this might not be a problem, but as list get bigger and bigger and the number of interactions on this list</p>\n"
    },
    "2sJuJG": {
      "id": "2sJuJG",
      "slug": "not-everything-in-the-store",
      "title": "Not everything is in the store",
      "content": "<h3>Not everything is in the store</h3>\n<p>NgRx/Store (or Redux in general) provides us with a lot of great features and can be used in a lot of use cases. In some cases however, this pattern can be overkill and should be avoided. As a general rule of thumb, the following listing will help you to know when it helps to put data into the store.</p>\n<ul>\n<li>When data is shared between components that are in totally different places in the component tree. By putting this data into the store, it is easier to consume this data in those components.</li>\n<li>State that needs to be hydrated between page reloads. If you want your component to look the same way as it did before it was destroyed.</li>\n<li>State that can be updated from multiple places. Let’s say you have a list of users which can be updated through crud operations. In that case it is easier to manage this by putting this data into the store.</li>\n</ul>\n<p>This is a non exhausitve listing and there will always be exceptions to the rule. In most cases however, keeping to data that complies with one or more points in this list, is a good idea.</p>\n<p>In the following cases, using Redux might NOT be the best idea.</p>\n<ul>\n<li>When caching data from a backend call. If you want to cache data coming from a backend call, you can easily accomplish this by keeping a reference to the <code>Observable</code> from the <code>HttpClient</code> and adding a <code>shareReplay(1)</code> operator to it. This operator will cache the underlying result of the backend call and return it to every subsequent subscriber without re-executing it.</li>\n<li>When state is only needed for the lifecyle of the component. In cases where the data is added to the store, just to be removed on the <code>ngOnDestroy</code> lifecycle hook, it doens’t have any benefits.</li>\n</ul>\n"
    },
    "2g7vDW": {
      "id": "2g7vDW",
      "slug": "aot-compilation",
      "title": "AOT Compilation",
      "source": "https://github.com/mgechev/angular-performance-checklist",
      "author": {
        "name": "Minko Gechev",
        "url": "https://twitter.com/mgechev"
      },
      "content": "<h3>Use Ahead-of-Time Compilation</h3>\n<p>AoT can be helpful not only for achieving more efficient bundling by performing tree-shaking, but also for improving the runtime performance of our applications. The alternative of AoT is Just-in-Time compilation (JiT) which is performed runtime, therefore we can reduce the amount of computations required for rendering of our application by performing the compilation as part of our build process.</p>\n<h3>Tooling</h3>\n<ul>\n<li><a href=\"https://github.com/angular/angular/tree/master/packages/compiler-cli\">@angular/compiler-cli</a> - a drop-in replacement for <a href=\"https://www.npmjs.com/package/typescript\">tsc</a> which statically analyzes our application and emits TypeScript/JavaScript for the component’s templates.</li>\n<li><a href=\"https://github.com/mgechev/angular-seed\">angular2-seed</a> - a starter project which includes support for AoT compilation.</li>\n<li><a href=\"https://cli.angular.io/\">Angular CLI</a> Using the ng serve --prod</li>\n</ul>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"http://blog.mgechev.com/2016/08/14/ahead-of-time-compilation-angular-offline-precompilation/\">Ahead-of-Time Compilation in Angular</a> by Minko Gechev</li>\n</ul>\n"
    },
    "Z8rHxb": {
      "id": "Z8rHxb",
      "slug": "bundling",
      "title": "Bundling",
      "source": "https://github.com/mgechev/angular-performance-checklist",
      "author": {
        "name": "Minko Gechev",
        "url": "https://twitter.com/mgechev"
      },
      "content": "<h3>Bundling</h3>\n<p>Bundling is a standard practice aiming to reduce the number of requests that the browser needs to perform in order to deliver the application requested by the user. In essence, the bundler receives as an input a list of entry points and produces one or more bundles. This way, the browser can get the entire application by performing only a few requests, instead of requesting each individual resource separately.</p>\n<p>As your application grows bundling everything into a single large bundle would again be counter productive. Explore Code Splitting techniques using Webpack.</p>\n<p><strong>Additional http requests will not be a concern with HTTP/2 because of the server push feature.</strong></p>\n<h4>Tooling</h4>\n<p>Tools which allows us to bundle our applications efficiently are:</p>\n<ul>\n<li><a href=\"https://github.com/angular/angular-cli\">Angular CLI</a> - A command line interface for Angular which makes it easy to create an application that already works, right out of the box. It already follows many best practices and focuses on performance.</li>\n<li><a href=\"https://webpack.js.org\">Webpack</a> - provides efficient bundling by performing <a href=\"#tree-shaking\">tree-shaking</a>.</li>\n<li><a href=\"https://webpack.js.org/guides/code-splitting/\">Webpack Code Splitting</a> - Techniques to split your code.</li>\n<li><a href=\"https://medium.com/webpack/webpack-http-2-7083ec3f3ce6#.46idrz8kb\">Webpack &amp; http2</a> - Need for splitting with http2.</li>\n<li><a href=\"https://github.com/rollup/rollup\">Rollup</a> - provides bundling by performing efficient tree-shaking, taking advantage of the static nature of the ES2015 modules.</li>\n<li><a href=\"https://github.com/google/closure-compiler\">Google Closure Compiler</a> - performs plenty of optimizations and provides bundling support. Originally written in Java, since recently it also has a <a href=\"https://www.npmjs.com/package/google-closure-compiler-js\">JavaScript version</a> which can be <a href=\"https://www.npmjs.com/package/google-closure-compiler-js\">found here</a>.</li>\n<li><a href=\"https://github.com/systemjs/builder\">SystemJS Builder</a> - provides a single-file build for SystemJS of mixed-dependency module trees.</li>\n<li><a href=\"http://browserify.org/\">Browserify</a>.</li>\n</ul>\n"
    },
    "Z13mvQ4": {
      "id": "Z13mvQ4",
      "slug": "change-detection-optimization",
      "title": "ChangeDetection Optimization",
      "content": "<h3>Using OnPush</h3>\n"
    },
    "iOnTI": {
      "id": "iOnTI",
      "slug": "lazy-loading",
      "title": "Lazy Loading",
      "content": "<h3>Lazy load feature modules</h3>\n<p>Angular is using a modular architecture. This allows us to split the application into different modules. When using the Angular CLI, it becomes really easy to lazy load these modules via our route definitions.</p>\n<pre class=\"hljs\"><code>[\n  { path: <span class=\"hljs-string\">'/heroes'</span>, loadChildren: <span class=\"hljs-string\">'app/heroes/heroes.module#HeroesModule'</span> },\n  ...\n]\n</code></pre>\n<p>Lazy loading will make the initial page load faster and makes sure only code that is actually needed is loaded up front. Everything else is loaded when it’s needed.</p>\n"
    },
    "gLB8Y": {
      "id": "gLB8Y",
      "slug": "prod-mode",
      "title": "Enable Production Mode",
      "source": "https://github.com/mgechev/angular-performance-checklist",
      "author": {
        "name": "Minko Gechev",
        "url": "https://twitter.com/mgechev"
      },
      "content": "<h3>Use <code>enableProdMode</code></h3>\n<p>In development mode Angular performs some extra checks in order to verify that performing change detection does not result to any additional changes to any of the bindings. This way the frameworks assures that the unidirectional data flow has been followed.</p>\n<p>In order to disable these changes for production to not forget to invoke enableProdMode:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> { enableProdMode } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@angular/core'</span>;\n\n<span class=\"hljs-keyword\">if</span> (ENV === <span class=\"hljs-string\">'production'</span>) {\n  enableProdMode();\n}\n</code></pre>\n"
    },
    "Z2pAnXm": {
      "id": "Z2pAnXm",
      "slug": "pure-pipes",
      "title": "Pure Pipes",
      "source": "https://github.com/mgechev/angular-performance-checklist",
      "author": {
        "name": "Minko Gechev",
        "url": "https://twitter.com/mgechev"
      },
      "content": "<h3>Use pure Pipes</h3>\n<p>As argument the <code>@Pipe</code> decorator accepts an object literal with the following format:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">interface</span> PipeMetadata {\n  name: <span class=\"hljs-built_in\">string</span>;\n  pure: <span class=\"hljs-built_in\">boolean</span>;\n}\n</code></pre>\n<p>The pure flag indicates that the pipe is not dependent on any global state and does not produce side-effects. This means that the pipe will return the same output when invoked with the same input. This way Angular can cache the outputs for all the input parameters the pipe has been invoked with, and reuse them in order to not have to recompute them on each evaluation.</p>\n<p>The default value of the pure property is true.</p>\n"
    },
    "AvD9O": {
      "id": "AvD9O",
      "slug": "template-whitespace",
      "title": "Remove Template Whitespace",
      "source": "https://github.com/mgechev/angular-performance-checklist",
      "author": {
        "name": "Minko Gechev",
        "url": "https://twitter.com/mgechev"
      },
      "content": "<h3>Remove Template Whitespace</h3>\n<p>Although we don’t see the whitespace character (a character matching the <code>\\s</code> regex) it is still represented by bytes which are transfered over the network. If we reduce the whitespace from our templates to minimum we will be respectively able to drop the bundle size of the AoT code even further.</p>\n<p>Thankfully, we don’t have to do this manually. The <code>ComponentMetadata</code> interface provides the property <code>preserveWhitespaces</code> which by default has value <code>true</code>, because removing the whitespace always may influence the DOM layout. In case we set the property to <code>false</code> Angular will trim the unnecessary whitespace which will lead to further reduction of the bundle size.</p>\n<ul>\n<li><a href=\"https://angular.io/api/core/Component#preserveWhitespaces\">preserveWhitespaces in the Angular docs</a></li>\n</ul>\n"
    },
    "ZfxFUd": {
      "id": "ZfxFUd",
      "slug": "track-by-option-on-ng-for",
      "title": "use trackBy option on *ngFor",
      "source": "https://github.com/mgechev/angular-performance-checklist#use-trackby-option-for-ngfor-directive",
      "author": {
        "name": "Minko Gechev",
        "url": "https://twitter.com/mgechev"
      },
      "content": "<h3>Use the trackBy option on *ngFor</h3>\n<p>The *ngFor directive is used for rendering a collection. By default *ngFor identifies object uniqueness by reference.</p>\n<p>Which means when developer breaks reference to object during updating item’s content Angular treats it as removal of the old object and addition of the new object. This effects in destroying old DOM node in the list and adding new DOM node on its place.</p>\n<p>Developer can provide a hint for angular how to identify object uniqueness: custom tracking function as the trackBy option for the *ngFor directive. Tracking function takes two arguments: index and item. Angular uses the value returned from tracking function to track items identity. It is very common to use ID of the particular record as the unique key.</p>\n<h4>Example</h4>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  selector: <span class=\"hljs-string\">'yt-feed'</span>,\n  template: <span class=\"hljs-string\">`\n  &lt;h1&gt;Your video feed&lt;/h1&gt;\n  &lt;yt-player *ngFor=\"let video of feed; trackBy: trackById\" [video]=\"video\"&gt;&lt;/yt-player&gt;\n`</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> YtFeedComponent {\n  feed = [\n    {\n      id: <span class=\"hljs-number\">3849</span>, <span class=\"hljs-comment\">// note \"id\" field, we refer to it in \"trackById\" function</span>\n      title: <span class=\"hljs-string\">\"Angular in 60 minutes\"</span>,\n      url: <span class=\"hljs-string\">\"http://youtube.com/ng2-in-60-min\"</span>,\n      likes: <span class=\"hljs-string\">\"29345\"</span>\n    },\n    <span class=\"hljs-comment\">// ...</span>\n  ];\n\n  trackById(index, item) {\n    <span class=\"hljs-keyword\">return</span> item.id;\n  }\n}\n</code></pre>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://angular.io/docs/ts/latest/api/common/index/NgFor-directive.html\">NgFor directive</a></li>\n<li><a href=\"https://netbasal.com/angular-2-improve-performance-with-trackby-cc147b5104e5\">Angular — Improve performance with trackBy</a> by Netanel Basal</li>\n</ul>\n"
    },
    "PaBkH": {
      "id": "PaBkH",
      "slug": "404-route",
      "title": "404 Route",
      "content": "<h3>Defining a 404 route</h3>\n<p>Every application should define a 404 route. This is a route to be shown whenever the user tries to go to an non existing route.</p>\n<pre class=\"hljs\"><code>[\n  ...,\n  { path: <span class=\"hljs-string\">'**'</span>, redirectTo: <span class=\"hljs-string\">'/not-found'</span>, component: <span class=\"hljs-string\">'NotFoundComponent'</span> },\n]\n</code></pre>\n<p>This route definition uses a wildcard as a path. Since the Angular router will render the first definitions that matches, be sure to always put this route definition last!</p>\n"
    },
    "5ScV4": {
      "id": "5ScV4",
      "slug": "default-route",
      "title": "Default Route",
      "content": "<h3>Defining a default route</h3>\n<p>Every application should define a default route. This is the route that will be used whenever the user goes to <code>/</code>.</p>\n<pre class=\"hljs\"><code>[\n  { path: <span class=\"hljs-string\">''</span>, redirectTo: <span class=\"hljs-string\">'/heroes'</span>, pathMatch: <span class=\"hljs-string\">'full'</span> },\n  ...\n]\n</code></pre>\n<p>Note that <code>pathMatch: full</code> should be used to make sure that this route definitions is only triggered when the user is going to <code>/</code>.</p>\n"
    },
    "Z1WXxTy": {
      "id": "Z1WXxTy",
      "slug": "preloading",
      "title": "Preloading Strategy",
      "content": "<h3>Define a preloading strategy</h3>\n<p>When using lazy loading, it may be interesting to define a preloading strategy. This strategy will define when modules, that are not yet requested, should be loaded.</p>\n<p>Depending on the application you are building and whether you have to deal with low bandwidth, a different strategy may be applied. When working on an application that will be used only on a steady WiFi connection, it makes sense to preload all of the modules. When your application will be used mainly on slow 3G connections, you should only load the modules that are most likely used.</p>\n<h3>Defining a custom preload strategy</h3>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> MyCustomPreloadingStrategy <span class=\"hljs-keyword\">implements</span> PreloadingStrategy {\n  preload(route: Route, load: <span class=\"hljs-built_in\">Function</span>): Observable&lt;<span class=\"hljs-built_in\">any</span>&gt; {\n    <span class=\"hljs-comment\">// Implement your strategy here</span>\n  }\n}\n</code></pre>\n<h3>Use preloading strategy</h3>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@NgModule</span>({\n  imports: [\n    ...modules,\n    <span class=\"hljs-comment\">// Existing Preloading Strategy</span>\n    RouterModule.forRoot(routes, { preloadingStrategy: PreloadAllModules })\n\n    <span class=\"hljs-comment\">// Custom Preloading Strategy</span>\n    RouterModule.forRoot(routes, { preloadingStrategy: MyCustomPreloadingStrategy });\n  ],\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> AppModule {}\n</code></pre>\n"
    },
    "wpc6W": {
      "id": "wpc6W",
      "slug": "use-guards",
      "title": "Use guards for parts that should be restricted",
      "content": "<h3>Use guards for parts that should be restricted</h3>\n<p>We can use guards to allow or disallow route changes. Every part of your application that should be limited to users with certain roles should be protected with guards.</p>\n"
    },
    "Z1PcMvX": {
      "id": "Z1PcMvX",
      "slug": "async-pipe",
      "title": "Async pipe",
      "content": "<h3>Use the async pipe</h3>\n<p>Observables are the async paradigm used in Angular applications. We can ‘start’ Observables by subscribing to them. Whenever we do so, it is very important to also unsubscribe. Unsubscribing will clean up the resources being used by this stream. Otherwise, this might introduce memory leaks.</p>\n<p>The async pipe will:</p>\n<ul>\n<li>subscribe to an Observable</li>\n<li>unsubscribe from the Observable when it is destroyed</li>\n<li>mark this component for the next change detection cycle</li>\n</ul>\n<p>Using the async pipe as much as possible will make sure all the resources are cleaned up.</p>\n<h6>Using the async pipe</h6>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  template: <span class=\"hljs-string\">`{{data$ | async}}`</span>,\n  ...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent {\n  data$ = interval(<span class=\"hljs-number\">1000</span>);\n}\n</code></pre>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://blog.thoughtram.io/angular/2017/02/27/three-things-you-didnt-know-about-the-async-pipe.html\">Three things you didn’t know about the AsyncPipe</a> by Christoph Burgdorf</li>\n</ul>\n"
    },
    "bkHEY": {
      "id": "bkHEY",
      "slug": "caching",
      "title": "Caching",
      "content": "<h3>Caching</h3>\n"
    },
    "ZzpwmT": {
      "id": "ZzpwmT",
      "slug": "pipeable-operators",
      "title": "Pipeable Operators",
      "content": "<h5>Pipeable Operators</h5>\n<p>Since the release of RxJS 6, patch operators have been removed.</p>\n<p>You should not use patch operators anymore and avoid to write code like this:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'rxjs/add/observable/interval'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'rxjs/add/operator/map'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'rxjs/add/operator/filter'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'rxjs/add/operator/switchMap'</span>;\n\nObservable.interval(<span class=\"hljs-number\">1000</span>)\n  .filter(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">0</span>)\n  .map(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x*<span class=\"hljs-number\">2</span>)\n  .switchMap(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> mapToObservable(x))\n</code></pre>\n<p>Instead, you should write your code like this:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">import</span> { interval } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs'</span>;\n<span class=\"hljs-keyword\">import</span> { filter, map, switchMap } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'rxjs/operators'</span>;\n\nObservable.interval(<span class=\"hljs-number\">1000</span>)\n  .pipe(\n    filter(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">0</span>),\n    map(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x*<span class=\"hljs-number\">2</span>),\n    switchMap(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> mapToObservable(x)),\n  );\n</code></pre>\n"
    },
    "ZHuJoA": {
      "id": "ZHuJoA",
      "slug": "subjects",
      "title": "Subjects",
      "content": "<h5>Subjects</h5>\n"
    },
    "ZBbo7y": {
      "id": "ZBbo7y",
      "slug": "subscriptions",
      "title": "Subscriptions",
      "content": "<h5>Subscriptions</h5>\n"
    },
    "Z2hzSxp": {
      "id": "Z2hzSxp",
      "slug": "avoid-using-any",
      "title": "Avoid using any",
      "content": "<h3>Avoid the using of the any type</h3>\n<p>Typescript allows us to write code that is type checked. This provides huge benefits. Whenever we use the <code>any</code> type, we are basically telling Typescript to ignore the following section, thus loosing all benefits.</p>\n<p>If you are using a library which was written in JavaScript, and thus doesn’t have any types, you can probably find type definitions on npm for this when searching for ‘@types/${library-name}’.</p>\n<p>If you can not find types, try to define a type definition yourself. Using <code>any</code> should be an <strong>exception</strong>.</p>\n"
    },
    "23KPo0": {
      "id": "23KPo0",
      "slug": "define-interfaces-for-models",
      "title": "Define interfaces for models",
      "content": "<h3>Define interfaces for models</h3>\n<p>When working with APIs, define a type for every call you can perform. This will provide type safety in your own code.</p>\n<p>For example, if you know a backend request will return an object with the properties ‘userName’ and ‘password’, which both are strings, define the type like this:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">interface</span> User {\n  userName: <span class=\"hljs-built_in\">string</span>;\n  password: <span class=\"hljs-built_in\">string</span>;\n}\n</code></pre>\n"
    },
    "12Aq23": {
      "id": "12Aq23",
      "slug": "define-types-at-the-non-typed-boundaries",
      "title": "Define types at the non typed boundaries",
      "content": "<h3>Define types at the non typed boundaries of your app</h3>\n<p>All our Javascript code is written in Typescript. This means that we can leverage types. This code however interacts with different non typed boundaries such as the html layer (think of events) and backend requests. On the boundaries of these interactions, we must always define types to leverage the full power of Typescript.</p>\n<p>For example when working with custom events:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">@Component</span>({\n  template: <span class=\"hljs-string\">`&lt;some-other-component (someEvent)=\"someEventHandler($event)\"&gt;&lt;/some-other-component&gt;`</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">class</span> SomeComponent {\n  someEventHandler(event: TypeForThisEvent) {\n    <span class=\"hljs-comment\">// ...</span>\n  }\n}\n</code></pre>\n<p><code>TypeForThisEvent</code> will make sure that the non typed html event is typed inside of our Typescript code.</p>\n"
    },
    "ZEhkug": {
      "id": "ZEhkug",
      "slug": "use-type-inference",
      "title": "Use type inference",
      "content": "<h3>Use type inference</h3>\n<p>Typescript is a typed language which supports type inference. This means that:</p>\n<ul>\n<li>you can define the type for a certain variable</li>\n<li>Typescript is smart enough to deduct the type based on its location</li>\n</ul>\n<p>Leveraging the type inference will allow us to benefit from the power of Typescript without constantly having to define the types ourselves.</p>\n<p>Type inference example:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> example = <span class=\"hljs-string\">'typescript will infer the string type by default'</span>;\n</code></pre>\n<p>Here’s another example:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-number\">1</span> + <span class=\"hljs-number\">1</span>;\n</code></pre>\n<p>The type of <code>result</code> will automatically, by inference, be number.</p>\n"
    }
  }
}